* Package System

The first thing we need to do is initialize =emacs='s package
system. That's achieved with the following =elisp= code.

#+BEGIN_SRC emacs-lisp
  (require 'package)

  ;; (add-to-list 'package-archives
  ;; 	     '("melpa" . "http://melpa.org/packages/"))

  (setq package-archives '(("melpa" . "http://melpa.org/packages/")
			   ("gnu" . "http://mirrors.163.com/elpa/gnu/")))

  (package-initialize)
#+END_SRC
* Basics

This is where I'll setup some basic defaults for =emacs=. Things like
=user-full-name=, =user-mail-address= and similar will be here.

#+BEGIN_SRC emacs-lisp
  (setq user-full-name "Felipe Balbi"
	user-mail-address "felipe.balbi@linux.intel.com"
	calendar-latitude 60.17
	calendar-longitude 24.94
	calendar-location-name "Helsinki, FI"
	inhibit-startup-screen t
	make-backup-files nil)
  (global-prettify-symbols-mode t)
#+END_SRC

Depending on the machine I am, I might need some extra
configuration. For example, at the office I need a proxy to get
through to the outside world. To cope with that, I'll add an optional
=site-local.el= file on such machines and conditionally load it.

#+BEGIN_SRC emacs-lisp
  (let ((filename (concat "~/.emacs.d/" (system-name) ".org.gpg")))
    (if (file-exists-p filename)
        (org-babel-load-file filename)))
#+END_SRC

After that, let's increase =emacs=' garbage collector threshold:

#+BEGIN_SRC emacs-lisp
  (setq gc-cons-threshold 50000000)	; Stolen from Howard Abrams :-)
#+END_SRC

I tend to hit =C-x C-c= by accident all the time. This little trick
helps me a lot

#+BEGIN_SRC emacs-lisp
  (setq confirm-kill-emacs 'yes-or-no-p)
#+END_SRC

Numbers, numbers, numbers...

#+BEGIN_SRC emacs-lisp
  (setq fill-column 80)
  (column-number-mode)

  (add-hook 'prog-mode-hook #'display-line-numbers-mode)

#+END_SRC

Some indentation configuration using mode-specific hooks

#+BEGIN_SRC emacs-lisp
  (add-hook 'sh-mode-hook
	    (lambda ()
	       (setq sh-basic-offset 2
		     sh-indentation 2)))

  (add-hook 'ruby-mode-hook
	    (lambda ()
	       (setq ruby-indent-level 2)))

  (add-hook 'js-mode-hook
	    (lambda ()
	       (setq js-indent-level 2)
	       (setq indent-tabs-mode nil)))

  (add-hook 'sgml-mode-hook
	    (lambda ()
	      (setq indent-tabs-mode nil)))

  (add-hook 'c-mode-hook
	    (lambda ()
	       (c-set-style "linux")
	       (setq c-basic-offset 8
		     c-block-comment-prefix "* ")
	       (c-set-offset 'arglist-intro '++)
	       (c-set-offset 'arglist-cont '++)
	       (c-set-offset 'arglist-cont-nonempty '++)
	       (setq indent-tabs-mode t)))

  (add-hook 'awk-mode-hook
	    (lambda ()
	       (c-set-style "awk")))
#+END_SRC

And I like to highlight current line

#+BEGIN_SRC emacs-lisp
  (when window-system (global-hl-line-mode))
#+END_SRC

I wanna see a simple clock in my modeline, so let's enable
=display-time-mode=

#+BEGIN_SRC emacs-lisp
  (setq display-time-24hr-format t)
  (display-time-mode 1)
#+END_SRC

Better grep:

#+BEGIN_SRC emacs-lisp
  (setq grep-command "grep --color --nH -e")
#+END_SRC

Always follow symlinks:

#+BEGIN_SRC emacs-lisp
  (setq vc-follow-symlinks t)
#+END_SRC

* Setup a new home for =custom-file=

Well, I don't want =custom= touching my beautiful =init.el=. Let's give
it a dumping ground.

#+BEGIN_SRC emacs-lisp
  (unless (file-exists-p "~/.emacs.d/custom.el")
    (with-temp-buffer (write-file "~/.emacs.d/custom.el")))

  (setq custom-file "~/.emacs.d/custom.el")
  (load custom-file)
#+END_SRC

* Bars Galore

Don't you hate all these bars in =emacs=? I do, let's disable them:

#+BEGIN_SRC emacs-lisp
  (scroll-bar-mode -1)
  (horizontal-scroll-bar-mode -1)
  (menu-bar-mode -1)
  (tool-bar-mode -1)
#+END_SRC

* Install =use-package= if necessary

I really want to be able to just move to a new computer and have all my
configuration available in a way that I don't have to anything manually
anymore and still get *my* =emacs= the way *I* like it.

This is likely gonna cost me some init time, but every time =emacs=
starts out, I'll check if we need to install =use-package= and
conditionally install it.

#+BEGIN_SRC emacs-lisp
  (unless (package-installed-p 'use-package)
    (package-refresh-contents)
    (package-install 'use-package))

  (eval-when-compile
    (require 'use-package))
#+END_SRC

* Setup =PATH= variable

All set =PATH= and =MANPATH= from shell, even when initialized from
GUI helpers like =dmenu= or =Spotlight=

#+BEGIN_SRC emacs-lisp
  (use-package exec-path-from-shell
    :ensure t
    :config
    (add-to-list 'exec-path-from-shell-variables "SSH_AUTH_SOCK")
    :init
    (exec-path-from-shell-initialize))

#+END_SRC

* Setup =auto-fill-mode=

I like to have =auto-fill-mode= enabled on all my text
buffers. Easiest way of achieve that is to add =turn-on-auto-fill= to
=text-mode-hook=

#+BEGIN_SRC emacs-lisp
  (add-hook 'text-mode-hook 'turn-on-auto-fill)
#+END_SRC

* Setup =company-mode=

Auto-completion is always useful, so I'll be using it as much as
possible.

#+BEGIN_SRC emacs-lisp
  (use-package company
    :ensure t
    :bind ("TAB" . company-indent-or-complete-common)
    :defer 1
    :config (global-company-mode))
#+END_SRC

* Setup =night-owl-theme=

  Switched to Night Owl Theme after using it under =vscode=. Let's
  give it a go here.

#+BEGIN_SRC emacs-lisp
  (use-package night-owl-theme
    :ensure t
    :config
    (load-theme 'night-owl t))
#+END_SRC

* Setup =geiser=

=guile= is a language that lately I've been trying to get acquainted to
and, as such, I need a cool way of communicating with a =REPL= from
inside =emacs=. =gueiser= seems to be a good choice for that

#+BEGIN_SRC emacs-lisp
  (use-package geiser
    :ensure t)
#+END_SRC

* Setup =paredit=

This is probably the most awkward mode to get used to. Still, it's so
darn helpful that I just have to use it.

#+BEGIN_SRC emacs-lisp
  (use-package paredit
    :ensure t
    :config
    (add-hook 'emacs-lisp-mode-hook       #'enable-paredit-mode)
    (add-hook 'eval-expression-minibuffer-setup-hook #'enable-paredit-mode)
    (add-hook 'ielm-mode-hook             #'enable-paredit-mode)
    (add-hook 'lisp-mode-hook             #'enable-paredit-mode)
    (add-hook 'lisp-interaction-mode-hook #'enable-paredit-mode)
    (add-hook 'scheme-mode-hook           #'enable-paredit-mode))
#+END_SRC

* Setup =show-parens=

This makes it a lot easier to see matching parens

#+BEGIN_SRC emacs-lisp
  (show-paren-mode 1)
#+END_SRC

* Setup =rainbow-delimiters=

As a complement to =paredit= I want my parens to be easy to see, hence =rainbow-delimiters=

#+BEGIN_SRC emacs-lisp
  (use-package rainbow-delimiters
    :ensure t
    :config
    (add-hook 'emacs-lisp-mode-hook       #'rainbow-delimiters-mode)
    (add-hook 'eval-expression-minibuffer-setup-hook #'rainbow-delimiters-mode)
    (add-hook 'ielm-mode-hook             #'rainbow-delimiters-mode)
    (add-hook 'lisp-mode-hook             #'rainbow-delimiters-mode)
    (add-hook 'lisp-interaction-mode-hook #'rainbow-delimiters-mode)
    (add-hook 'scheme-mode-hook           #'rainbow-delimiters-mode))
#+END_SRC

* Setup =prettify-symbols-mode=

I like to have nice looking =lambda= characters on all my lisp-y
modes. Let's push the =lambda= character to other mode hooks too.

We also have a rather cute symbol for =function= on =js-mode=.

#+BEGIN_SRC emacs-lisp
  (defun push-pretty-characters ()
    "Push pretty characters to mode-specific prettify-symbols-alist"
    (push '("lambda" . #x03bb) prettify-symbols-alist))

  (add-hook 'emacs-lisp-mode-hook       #'push-pretty-characters)
  (add-hook 'eval-expression-minibuffer-setup-hook #'push-pretty-characters)
  (add-hook 'ielm-mode-hook             #'push-pretty-characters)
  (add-hook 'lisp-mode-hook             #'push-pretty-characters)
  (add-hook 'lisp-interaction-mode-hook #'push-pretty-characters)
  (add-hook 'scheme-mode-hook           #'push-pretty-characters)

  (add-hook 'js-mode-hook (lambda ()
			     (push '("function" . ?ƒ) prettify-symbols-alist)))
#+END_SRC

* Setup =helm=

Oh, dear =helm=; how could I possibly live without you.

#+BEGIN_SRC emacs-lisp
  (use-package helm
    :ensure t
    :bind (("M-x" . helm-M-x)
           ("C-x r b" . helm-bookmarks)
           ("M-y" . helm-show-kill-ring)
           ("C-x C-f" . helm-find-files)
	   :map helm-find-files-map
	   ("TAB" . helm-execute-persistent-action)
	   :map help-map
	   ("TAB" . helm-execute-persistent-action))
    :config
    (require 'helm-config)
    (setq helm-split-window-in-side-p t
          helm-move-to-line-cycle-in-source t
          helm-ff-search-library-in-sexp t
          helm-scroll-amount 8
          helm-ff-file-name-history-use-recentf t
	  helm-mode-fuzzy-match t
	  helm-completion-in-region-fuzzy-match t)
    (helm-mode t))
#+END_SRC

* Setup =helm-ls-git=

A very good extension to =helm=...

#+BEGIN_SRC emacs-lisp
  (use-package helm-ls-git
    :ensure t
    :bind ("C-x C-d" . helm-browse-project))
#+END_SRC

* Setup =helm-git-grep=

#+BEGIN_SRC emacs-lisp
  (use-package helm-git-grep
    :ensure t
    :bind (("C-c g" . helm-git-grep)
           (:map isearch-mode-map
                    ("C-c g" . helm-git-grep-from-isearch))))
#+END_SRC

* Setup =powerline=

=powerline= turns =emacs='s mode line into something so useful that I
can't live without it anymore.

Note that in order to use =powerline= we need to install a
=powerline=-patched font. I kinda line DejaVu Sans and that's what I'll
use.

For the sake of documentation, here's how I've manually setup
=powerline=-patched fonts.

#+BEGIN_SRC sh :eval no
  $ git clone https://github.com/powerline/fonts.git
  $ cd fonts
  $ ./install.sh
#+END_SRC

Now, let's get going with setting up =powerline=

#+BEGIN_SRC emacs-lisp
  (set-face-attribute 'default nil
                      :font "DejaVu Sans Mono for Powerline:style=Book"
                      :height 110)

  (use-package powerline
    :ensure t
    :config (powerline-default-theme))
#+END_SRC

* Setup =org= and =org-bullets=

=org= is =emacs='s organizer package. I use it a lot and really enjoy
it. Let's set it up.

First we will be using our local copy of org git tree:

#+BEGIN_SRC emacs-lisp
  (add-to-list 'load-path "~/workspace/org-mode/lisp")
  (add-to-list 'load-path "~/workspace/org-mode/contrib/lisp")
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package org
    :ensure t
    :pin manual
    :bind
    (("C-c l" . org-store-link)
     ("C-c a" . org-agenda)
     ("C-c c" . org-capture)
     ("C-c b" . org-switchb))
    :config
    (require 'ox-odt nil t)
    (require 'org-notmuch nil t)
    (add-to-list 'org-modules 'org-habit))

  (use-package org-bullets
    :ensure t
    :config
    (add-hook 'org-mode-hook
	      (lambda () (org-bullets-mode t)))
    (setq org-hide-leading-stars t))
#+END_SRC

with that out of the way, let's configure our preferred =org-directory=
location and point =org= to our org files.

#+BEGIN_SRC emacs-lisp
  (setq-default org-directory "~/workspace/org"
	org-default-notes-file (concat org-directory "/notes.org")
	org-agenda-files (directory-files-recursively
			  org-directory ".org")
	org-archive-location (concat org-directory "/archive/"
				     (format-time-string "%Y")
				     ".org::")
	org-return-follows-link t
	org-ellipsis "↴"
	org-src-fontify-natively t
	org-src-tab-acts-natively t
	org-enforce-todo-dependencies t
	org-enforce-todo-checkbox-dependencies t
	org-agenda-dim-blocked-tasks t)
#+END_SRC

Configuring some useful TODO keywords

#+BEGIN_SRC emacs-lisp
  (setq org-todo-keywords
	'((sequence "TODO(t@)" "IN PROGRESS(p@)" "|"
		    "DONE(d@)" "CANCELED(c@)"
		    "BLOCKED(b@)" "AWAITING(a@)")))
#+END_SRC

Track completion of a task

#+BEGIN_SRC emacs-lisp
  (setq org-log-done 'time)
#+END_SRC

Track notes into a drawer

#+BEGIN_SRC emacs-lisp
  (setq org-log-into-drawer t)
#+END_SRC

Define priorities

#+BEGIN_SRC emacs-lisp
  (setq org-highest-priority ?A
	org-lowest-priority ?E
	org-default-priotiy ?E)
#+END_SRC

Some =org-templates=

#+BEGIN_SRC emacs-lisp
  (setq org-capture-templates
	'(
	  ("t" "Todo" entry (file "todo.org")
	   "* TODO %^{Task}\n:PROPERTIES:\n:Captured: %T\n:END:\n%?\n\n%i")
	  ("n" "Note" entry (file+datetree "notes.org")
	   "* %?\nEntered on %U\n  %i\n  %a")
	  ))
#+END_SRC

* Setup =org-jira=
#+BEGIN_SRC emacs-lisp
  (use-package org-jira
    :ensure t)
#+END_SRC
* Setup =ox-ioslide=

=ox-ioslide= helps us exporting =org= documents to Google I/O HTML5
slides. This can come in very handy ;-)

#+BEGIN_SRC emacs-lisp
  (use-package ox-ioslide
    :ensure t)
#+END_SRC

* Setup =ox-rst=

=ox-rst= will be used to export =org= documents to =ReST= format which
is used as Linux' documentation source.

#+BEGIN_SRC emacs-lisp
  (use-package ox-rst
    :ensure t)
#+END_SRC

* Setup =magit=

This is simple to configure.

#+BEGIN_SRC emacs-lisp
  (use-package magit
    :ensure t
    :config (setq magit-diff-use-overlays nil
                  magit-commit-arguments '("--signoff"))
    :bind ("C-x g" . magit-status))
#+END_SRC

* Setup =eshell=

Really not much here, I just need a key chord to start =eshell= at will

#+BEGIN_SRC emacs-lisp
  (use-package eshell
    :ensure t
    :bind ("C-c t" . eshell))
#+END_SRC

* Setup =engine-mode=

=engine-mode= helps me starting out searches from within =emacs=. It's
a bit useful and I kinda like it.

#+BEGIN_SRC emacs-lisp
  (use-package engine-mode
    :ensure t
    :config
    (engine/set-keymap-prefix (kbd "C-c s"))

    (defengine duckduckgo
      "https://duckduckgo.com/?q=%s"
      :keybinding "d")

    (defengine google
      "https://www.google.com/search?ie=utf-8&oe=utf-8&q=%s"
      :keybinding "g")

    (defengine wikipedia
      "https://en.wikipedia.org/w/index.php?title=Special:Search&go=Go&search=%s"
      :keybinding "w")

    (defengine wolfram-alpha
      "https://www.wolfram-alpha.com/input/?i=%s")

    (defengine youtube
      "https://www.youtube.com/results?aq=f&oq=&search_query=%s"
      :keybinding "y")

    (defengine 17track
      "http://www.17track.net/en/track?nums=%s"
      :keybinding "t")

    (engine-mode t))
#+END_SRC

* Setup =notmuch=

I've been using =notmuch= for mailing for quite a while.

#+BEGIN_SRC emacs-lisp
  (use-package notmuch
    :ensure t
    :config
    (require 'smtpmail)
    (add-hook 'message-setup-hook 'mml-secure-message-sign-pgpmime)
    (setq-default message-kill-buffer-on-exit t
		  mail-specify-envelope-from t
		  message-send-mail-function 'message-smtpmail-send-it
		  smtpmail-smtp-server "smtp.intel.com"
		  smtpmail-smtp-service 25
		  notmuch-crypto-process-mime t
		  notmuch-show-indent-content nil)) ; my saved searches are missing. Should they be in site-local.el ?
#+END_SRC

* Setup =ledger-mode=

I use =ledger-mode= for managing my finances.

#+BEGIN_SRC emacs-lisp
  (use-package ledger-mode
    :ensure t
    :config
    (add-to-list 'auto-mode-alist '("\\.ledger\\'" . ledger-mode))
    (setq ledger-clear-whole-transactions t
          ledger-reconcile-default-commodity "€"
          ledger-reconcile-force-window-bottom t
          ledger-master-file "~/workspace/accounting/general.ledger"
          ledger-reports '(("bal" "%(binary) -f %(ledger-file) bal -B")
                           ("reg" "%(binary) -f %(ledger-file) reg")
                           ("payee" "%(binary) -f %(ledger-file) reg @%(payee)")
                           ("account" "%(binary) -f %(ledger-file) reg %(account)"))))
#+END_SRC

* Setup =restclient=

Well, maybe I could play a bit with =restclient= every now and again
:-)

#+BEGIN_SRC emacs-lisp
  (use-package restclient
    :ensure t)
#+END_SRC
* Setup =rust=

We may decide to play a little with =rust=

#+BEGIN_SRC emacs-lisp
  (use-package rust-mode
    :ensure t)

  (use-package cargo
    :ensure t)

  (use-package flycheck-rust
    :ensure t)

  (use-package flymake-rust
    :ensure t
    :config
    (add-hook 'rust-mode-hook 'flymake-rust-load)
    (add-hook 'rust-mode-hook 'cargo-minor-mode)
    (add-hook 'flycheck-mode-hook #'flycheck-rust-setup)
    (setq flymake-rust-use-cargo 1))

  (use-package rust-playground
    :ensure t)
#+END_SRC
* Setup =octave-mode=

Use *.m as default extension for octave files

#+BEGIN_SRC emacs-lisp
  (add-to-list 'auto-mode-alist '("\\.m$" . octave-mode))
#+END_SRC
* Setup =julia-mode=

Julia is a great language and I want to play a little with it, let's
setup =julia-mode= to make that easier.

#+BEGIN_SRC emacs-lisp
  (use-package julia-mode
    :ensure t)
#+END_SRC
* Setup =markdown-mode=

#+BEGIN_SRC emacs-lisp
  (use-package markdown-mode
    :ensure t
    :mode (("README\\.md\\'" . gfm-mode)
	   ("\\.md\\'" . markdown-mode)
	   ("\\.markdown\\'" . markdown-mode))
    :init (setq markdown-command "pandoc"))
#+END_SRC
* Setup =helm-swoop=

#+BEGIN_SRC emacs-lisp
  (use-package helm-swoop
    :ensure t
    :bind
    ("C-s" . helm-swoop)
    ("C-r" . helm-swoop)
    ("C-c M-i" . helm-multi-swoop)
    ("C-c M-I" . helm-multi-swoop-all)
    ("C-c M-m" . helm-multi-swoop-current-mode)
    :config
    (define-key helm-swoop-map (kbd "M-i") 'helm-multi-swoop-all-from-helm-swoop)
    (define-key helm-swoop-map (kbd "C-r") 'helm-previous-line)
    (define-key helm-swoop-map (kbd "C-s") 'helm-next-line)
    (define-key helm-swoop-map (kbd "M-m") 'helm-multi-swoop-current-mode-from-helm-swoop)
    (define-key helm-multi-swoop-map (kbd "C-r") 'helm-previous-line)
    (define-key helm-multi-swoop-map (kbd "C-s") 'helm-next-line)
    (setq helm-multi-swoop-edit-save t)
    (setq helm-swoop-split-with-multiple-windows nil)
    (setq helm-swoop-split-direction 'split-window-vertically))
#+END_SRC

* Setup =impatient-mode=

  Who wants to constantly reload web pages while you're writing them,
  huh? =impatient-mode= to the rescue.

  #+BEGIN_SRC emacs-lisp
    (use-package impatient-mode
      :ensure t)
  #+END_SRC

  #+RESULTS:

* Setup =yasnippet=

#+BEGIN_SRC emacs-lisp
  (use-package yasnippet
    :ensure t
    :config
    (setq yas-verbosity 1
	  yas-wrap-around-region t)

    (with-eval-after-load 'yasnippet
      (setq yas-snippet-dirs (list yasnippet-snippets-dir
				     "~/.emacs.d/personal-snippets")))

    (yas-reload-all)
    (yas-global-mode))

  (use-package yasnippet-snippets
    :ensure t)
#+END_SRC

* Setup =flycheck=

  Install it

#+BEGIN_SRC emacs-lisp
  (use-package flycheck
    :ensure t
    :hook (vue-mode . flycheck-mode)
    :config (flycheck-add-mode 'javascript-eslint 'vue-mode))
#+END_SRC

* Setup =smartparens=

  Install it

#+BEGIN_SRC emacs-lisp
  (use-package smartparens
    :ensure t
    :hook (vue-mode . smartparens-strict-mode))
#+END_SRC

* Setup =vue-mode=

  Install it

#+BEGIN_SRC emacs-lisp
  (use-package vue-mode
    :ensure t
    :config (setq indent-tabs-mode nil)
    :init
    (add-hook 'mmm-mode-hook
	      (lambda ()
		(set-face-background 'mmm-default-submode-face nil)
		(setq mmm-submode-decoration-level 0)))
    (add-hook 'vue-mode-hook 'display-line-numbers-mode)
    (add-hook 'vue-mode-hook 'smartparens-strict-mode))

  #+END_SRC

* Setup =lsp-mode=

  Install it

#+BEGIN_SRC emacs-lisp
  (use-package lsp-mode
    :ensure t
    :hook (vue-mode . lsp)
    :commands lsp
    :config (setq lsp-prefer-flymake nil))

  (use-package lsp-ui
    :ensure t
    :commands lsp-ui-mode)

  (use-package company-lsp
    :ensure t
    :commands company-lsp)

  (use-package helm-lsp
    :ensure t
    :commands helm-lsp-workspace-symbol)
#+END_SRC

* Setup =slime=

I've started reading Land Of Lisp and will, therefore, play around
with Common Lisp. For that, I'll be using =slime=. Initially with
=clisp= backend (to follow the book as closely as possible), but I
plan on switching to =sbcl= later on.

#+BEGIN_SRC emacs-lisp
  (use-package slime
    :ensure t
    :config
    (setq inferior-lisp-program "/usr/local/bin/clisp")
    (setq slime-contribs '(slime-fancy)))
#+END_SRC

* Some extra keybindings for myself

These are super helpful for day to day use

#+BEGIN_SRC emacs-lisp
  (define-key global-map (kbd "C-1") 'text-scale-increase)
  (define-key global-map (kbd "C-0") 'text-scale-decrease)
#+END_SRC

* GnuPG 2

We're gonna tell =emacs= to use =gpg2=

#+BEGIN_SRC emacs-lisp
  (setq epg-gpg-program "/usr/bin/gpg2")
#+END_SRC

* Enable some disabled commands

Few commands I want to use but are disabled by default
  
#+BEGIN_SRC emacs-lisp
  (put 'narrow-to-region 'disabled nil)
  (put 'upcase-region 'disabled nil)
  (put 'downcase-region 'disabled nil)
  (put 'dired-find-alternate-file 'disabled nil)
#+END_SRC
* All The Icons

#+BEGIN_SRC emacs-lisp
  (use-package all-the-icons
    :ensure t)

  (use-package all-the-icons-dired
    :ensure t
    :config
    (add-hook 'dired-mode-hook 'all-the-icons-dired-mode))
#+END_SRC
